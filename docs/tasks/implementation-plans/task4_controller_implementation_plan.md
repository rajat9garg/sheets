# Controller Layer Implementation Plan for Cell Management

## Overview

This document outlines the detailed implementation plan for the controller layer of the Cell Management functionality in Task4. The controller layer will be responsible for handling incoming HTTP requests, validating input, invoking the appropriate service layer methods, and returning HTTP responses.

## Table of Contents

1. [Requirements](#1-requirements)
2. [Design Approach](#2-design-approach)
3. [Controller Interface (Generated)](#3-controller-interface-generated)
4. [Controller Implementation](#4-controller-implementation)
5. [Error Handling](#5-error-handling)
6. [Testing Strategy](#6-testing-strategy)

## 1. Requirements

The controller layer for Cell Management must:

1. Expose RESTful API endpoints as defined in the OpenAPI specification.
2. Validate incoming request parameters and bodies.
3. Delegate business logic to the `CellService`.
4. Handle exceptions thrown by the service layer and translate them into appropriate HTTP responses.
5. Extract `X-User-ID` from request headers for authorization (as per project requirements, no actual security implementation).
6. Return consistent JSON responses.

## 2. Design Approach

We'll use the following design patterns and Spring Boot features:

1. **Controller Pattern**: Standard Spring `@RestController` for handling web requests.
2. **Dependency Injection**: To inject `CellService` and other necessary components.
3. **Global Exception Handling**: Using `@ControllerAdvice` to centralize error handling and ensure consistent error responses.
4. **OpenAPI Code Generation**: The controller interface will be generated from the `api.yaml` OpenAPI specification, ensuring API consistency.

## 3. Controller Interface (Generated)

The controller interface will be automatically generated by the OpenAPI Generator plugin based on the `api.yaml` specification. This ensures that the implementation adheres strictly to the defined API contract.

Example (conceptual, actual generation will vary based on plugin configuration):

```kotlin
package com.sheets.api

import com.sheets.models.api.CellRequest
import com.sheets.models.api.CellResponse
import com.sheets.models.api.CellListResponse
import com.sheets.models.api.ErrorResponse
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

interface CellApi {

    @PostMapping("/api/v1/sheets/{sheetId}/cells")
    fun createOrUpdateCell(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long,
        @RequestBody cellRequest: CellRequest
    ): ResponseEntity<CellResponse>

    @GetMapping("/api/v1/sheets/{sheetId}/cells/{cellId}")
    fun getCell(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long,
        @PathVariable("cellId") cellId: String
    ): ResponseEntity<CellResponse>

    @GetMapping("/api/v1/sheets/{sheetId}/cells")
    fun getCells(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long
    ): ResponseEntity<CellListResponse>

    @DeleteMapping("/api/v1/sheets/{sheetId}/cells/{cellId}")
    fun deleteCell(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long,
        @PathVariable("cellId") cellId: String
    ): ResponseEntity<Void>
}
```

## 4. Controller Implementation

### 4.1 CellController

```kotlin
package com.sheets.controllers

import com.sheets.api.CellApi // Assuming this is the generated interface
import com.sheets.models.api.CellRequest
import com.sheets.models.api.CellResponse
import com.sheets.models.api.CellListResponse
import com.sheets.services.CellService
import com.sheets.services.SheetService // For sheet existence check if needed
import com.sheets.services.expression.exception.CircularDependencyException
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.server.ResponseStatusException

@RestController
class CellController(
    private val cellService: CellService,
    private val sheetService: SheetService // Inject SheetService to validate sheet existence/access
) : CellApi {

    override fun createOrUpdateCell(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long,
        @RequestBody cellRequest: CellRequest
    ): ResponseEntity<CellResponse> {
        // Basic validation (more comprehensive validation might be in service layer or DTO)
        if (cellRequest.data.isNullOrBlank()) {
            throw ResponseStatusException(HttpStatus.BAD_REQUEST, "Cell data cannot be empty")
        }
        
        // Validate sheet existence and user access before proceeding
        sheetService.getSheet(userId, sheetId) ?: throw ResponseStatusException(HttpStatus.NOT_FOUND, "Sheet not found or access denied")

        try {
            val createdOrUpdatedCell = cellService.createOrUpdateCell(
                userId = userId,
                sheetId = sheetId,
                row = cellRequest.row,
                column = cellRequest.column,
                data = cellRequest.data,
                dataType = cellRequest.dataType.name // Convert enum to string
            )
            return ResponseEntity.ok(createdOrUpdatedCell.toApiResponse()) // Map domain to API response
        } catch (e: IllegalArgumentException) {
            throw ResponseStatusException(HttpStatus.BAD_REQUEST, e.message, e)
        } catch (e: IllegalStateException) {
            throw ResponseStatusException(HttpStatus.CONFLICT, e.message, e)
        } catch (e: CircularDependencyException) {
            throw ResponseStatusException(HttpStatus.CONFLICT, "Circular dependency detected: ${e.path.joinToString(" -> ")}", e)
        } catch (e: Exception) {
            // Catch any other unexpected exceptions
            throw ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "An unexpected error occurred", e)
        }
    }

    override fun getCell(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long,
        @PathVariable("cellId") cellId: String
    ): ResponseEntity<CellResponse> {
        // Validate sheet existence and user access
        sheetService.getSheet(userId, sheetId) ?: throw ResponseStatusException(HttpStatus.NOT_FOUND, "Sheet not found or access denied")

        val cell = cellService.getCell(userId, cellId)
        return if (cell != null) {
            ResponseEntity.ok(cell.toApiResponse())
        } else {
            throw ResponseStatusException(HttpStatus.NOT_FOUND, "Cell not found")
        }
    }

    override fun getCells(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long
    ): ResponseEntity<CellListResponse> {
        // Validate sheet existence and user access
        sheetService.getSheet(userId, sheetId) ?: throw ResponseStatusException(HttpStatus.NOT_FOUND, "Sheet not found or access denied")

        val cells = cellService.getCellsBySheetId(userId, sheetId)
        val apiCells = cells.map { it.toApiResponse() }
        return ResponseEntity.ok(CellListResponse(apiCells))
    }

    override fun deleteCell(
        @RequestHeader("X-User-ID") userId: String,
        @PathVariable("sheetId") sheetId: Long,
        @PathVariable("cellId") cellId: String
    ): ResponseEntity<Void> {
        // Validate sheet existence and user access
        sheetService.getSheet(userId, sheetId) ?: throw ResponseStatusException(HttpStatus.NOT_FOUND, "Sheet not found or access denied")

        try {
            val deleted = cellService.deleteCell(userId, cellId)
            return if (deleted) {
                ResponseEntity.noContent().build()
            } else {
                throw ResponseStatusException(HttpStatus.NOT_FOUND, "Cell not found")
            }
        } catch (e: IllegalStateException) {
            throw ResponseStatusException(HttpStatus.CONFLICT, e.message, e)
        } catch (e: Exception) {
            throw ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "An unexpected error occurred", e)
        }
    }
}

// Extension function to map domain Cell to API CellResponse
fun com.sheets.models.domain.Cell.toApiResponse(): CellResponse {
    return CellResponse(
        id = this.id,
        sheetId = this.sheetId,
        row = this.row,
        column = this.column,
        data = this.data,
        dataType = CellResponse.DataType.valueOf(this.dataType.name),
        evaluatedValue = this.evaluatedValue,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt
    )
}

// Extension function to map domain DataType to API DataType
// This might be automatically generated or need manual mapping based on OpenAPI spec
// Assuming CellResponse.DataType is generated as an enum with same names
// If not, a more complex mapping function will be needed.

```

## 5. Error Handling

Error handling will be centralized using a `@ControllerAdvice` class to provide consistent JSON error responses. This will catch exceptions thrown by the controller or service layers and map them to appropriate HTTP status codes and `ErrorResponse` bodies.

### 5.1 GlobalExceptionHandler

```kotlin
package com.sheets.controllers.advice

import com.sheets.models.api.ErrorResponse
import com.sheets.services.expression.exception.CircularDependencyException
import com.sheets.services.expression.exception.ExpressionException
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.server.ResponseStatusException
import org.springframework.web.context.request.WebRequest

@ControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(ResponseStatusException::class)
    fun handleResponseStatusException(ex: ResponseStatusException, request: WebRequest): ResponseEntity<ErrorResponse> {
        val errorResponse = ErrorResponse(
            status = ex.statusCode.value(),
            message = ex.reason ?: "",
            details = ex.cause?.message ?: ""
        )
        return ResponseEntity(errorResponse, ex.statusCode)
    }

    @ExceptionHandler(IllegalArgumentException::class)
    fun handleIllegalArgumentException(ex: IllegalArgumentException, request: WebRequest): ResponseEntity<ErrorResponse> {
        val errorResponse = ErrorResponse(
            status = HttpStatus.BAD_REQUEST.value(),
            message = "Invalid request parameter",
            details = ex.message ?: ""
        )
        return ResponseEntity(errorResponse, HttpStatus.BAD_REQUEST)
    }

    @ExceptionHandler(IllegalStateException::class)
    fun handleIllegalStateException(ex: IllegalStateException, request: WebRequest): ResponseEntity<ErrorResponse> {
        val errorResponse = ErrorResponse(
            status = HttpStatus.CONFLICT.value(),
            message = "Resource conflict",
            details = ex.message ?: ""
        )
        return ResponseEntity(errorResponse, HttpStatus.CONFLICT)
    }

    @ExceptionHandler(CircularDependencyException::class)
    fun handleCircularDependencyException(ex: CircularDependencyException, request: WebRequest): ResponseEntity<ErrorResponse> {
        val errorResponse = ErrorResponse(
            status = HttpStatus.CONFLICT.value(),
            message = "Circular dependency detected",
            details = "Path: ${ex.path.joinToString(" -> ")}"
        )
        return ResponseEntity(errorResponse, HttpStatus.CONFLICT)
    }

    @ExceptionHandler(ExpressionException::class)
    fun handleExpressionException(ex: ExpressionException, request: WebRequest): ResponseEntity<ErrorResponse> {
        val errorResponse = ErrorResponse(
            status = HttpStatus.BAD_REQUEST.value(),
            message = "Expression error",
            details = ex.message ?: ""
        )
        return ResponseEntity(errorResponse, HttpStatus.BAD_REQUEST)
    }

    @ExceptionHandler(Exception::class)
    fun handleAllExceptions(ex: Exception, request: WebRequest): ResponseEntity<ErrorResponse> {
        val errorResponse = ErrorResponse(
            status = HttpStatus.INTERNAL_SERVER_ERROR.value(),
            message = "An unexpected error occurred",
            details = ex.message ?: ""
        )
        return ResponseEntity(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR)
    }
}
```

## 6. Testing Strategy

### 6.1 Unit Tests

Write unit tests for the `CellController` methods. Mock the `CellService` and `SheetService` to isolate the controller logic, focusing on request validation, parameter extraction, and proper response mapping.

### 6.2 Integration Tests

Write integration tests using `@SpringBootTest` and `MockMvc` to test the entire API flow from the controller down to the service layer (and potentially mocked repositories). This will verify the correct mapping of HTTP requests to service calls and the proper handling of responses and exceptions.

### 6.3 API Contract Tests

Utilize the generated OpenAPI specification to perform API contract testing, ensuring that the implemented API endpoints conform to the defined contract. This can be done using tools like Spring Cloud Contract or Postman/Newman.

### 6.4 Error Handling Tests

Specifically test various error scenarios (e.g., invalid input, sheet not found, cell locked, circular dependency) to ensure that the `GlobalExceptionHandler` correctly intercepts exceptions and returns the expected `ErrorResponse` with appropriate HTTP status codes.

## Conclusion

This implementation plan provides a detailed approach to implementing the controller layer for the Cell Management functionality. By leveraging OpenAPI code generation and Spring Boot's robust features, we will create a well-defined, testable, and maintainable API for cell operations.
